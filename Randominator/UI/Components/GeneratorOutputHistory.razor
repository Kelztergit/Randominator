@typeparam TItem

<div class="history-box @this.CssClass">
    @foreach (TItem item in this.OrderItems())
    {
        <div class="history-item @this.ItemCssClass">
            @this.RenderItem(item)
        </div>
    }
</div>

@code {
    [Parameter]
    public int MaxItems { get; set; } = -1;
    [Parameter]
    public RenderFragment<TItem> ItemTemplate { get; set; }
    [Parameter]
    public bool Reverse { get; set; }
    [Parameter]
    public string CssClass { get; set; }
    [Parameter]
    public string ItemCssClass { get; set; }

    private Queue<TItem> _items;

    protected override void OnParametersSet()
    {
        this.TrimCollection();
        base.OnParametersSet();
    }

    private void TrimCollection()
    {
        if (this._items == null)
            return;
        if (this.MaxItems < 0)
            return;
        while (this._items.Count > this.MaxItems)
            this._items.Dequeue();
    }

    public void Add(TItem item)
    {
        if (this._items == null)
            this._items = new Queue<TItem>(this.MaxItems);
        this._items.Enqueue(item);
        this.TrimCollection();
        base.StateHasChanged();
    }

    public void Clear()
    {
        this._items.Clear();
        this._items.TrimExcess();
        base.StateHasChanged();
    }

    private RenderFragment RenderItem(TItem item)
    {
        if (this.ItemTemplate == null)
            return @<text>@item</text>;
        return this.ItemTemplate(item);
    }

    private IEnumerable<TItem> OrderItems()
    {
        if (this._items == null)
            return Enumerable.Empty<TItem>();

        // Reverse order is actually... normal order, cause default order displays elements on top
        if (this.Reverse)
            return this._items;
        return this._items.Reverse();
    }
}
